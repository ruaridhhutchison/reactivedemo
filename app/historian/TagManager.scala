package historian

import akka.actor._
import scala.collection.immutable.{HashSet, Queue}
import play.api._

// There is one TagManager actor per tag 
// generated by the historian. The TagManager maintains
// a set of subscribers who are interested in receiving
// updates when new data is available for the tag.
class TagManager(tag: Int) extends Actor {
  
  // Import the supported messages
  import TagBroker._
  import TagManager._
  
  // Set of subscribers to this tag
  private var subscribers : HashSet[ActorRef] = HashSet.empty[ActorRef]
  
  // History of the last few tag values
  private var history = Queue[PointValue]()
  
  // Match on the received message
  def receive = {
    case Subscribe(tag, client) =>
      // Add the client to the set of subscribers
      Logger.info("Subscribing client to Tag " + tag)
      subscribers += client
    case Unsubscribe(tag, client) =>
      // Remove the client from the set of subscribers
      Logger.info("Unsubscribing client from Tag " + tag)
      subscribers -= client
    case History(tag, client) =>
      // Reply with the history for this tag
      client ! HistoryData(history.toArray)
    case Latest(tag, client) =>
      // Reply with the latest data for this tag
      if (history.length > 0)
        client ! TagData(history.last)
      else
        client ! TagData(PointValue(tag, 0, System.nanoTime()))
    case Dispatch(pv) =>
      // Maintain the tag value history
      if (history.length > 99)
        history = history.drop(1)
      history = history :+ pv
      // Send the latest data to all subscribers
      subscribers.foreach(_ ! TagData(pv))
    case _ =>
  }
}

object TagManager {
  
  // Supported operation messages
  case class Subscribe(tag: Int, client: ActorRef)
  case class Unsubscribe(tag: Int, client: ActorRef)
  case class History(tag: Int, client: ActorRef)
  case class Latest(tag: Int, client: ActorRef)
  
  // Supported data messages
  case class HistoryData(history: Array[PointValue])
  case class TagData(pv: PointValue)  
}